/*=================================================================================
–еализовать контроль чередовани€ фаз в трЄхфазном источнике напр€жени€.
==================================================================================*/

#include <inttypes.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <util/delay.h>

int Ua=0;
int Ub=0;
int Uc=0;
void adc_ini();
int16_t adc_read(uint8_t channel);
void phase_correct ();
void phase_incorrect ();

int main(){   
   DDRD = 0xFF; 				//включение портов на вывод дл€ индикации
   adc_ini();					//инициализаци€ ј÷ѕ
    
   while (1){
      Ua = (adc_read(1)-512);               	//чтение значени€ синусоиды с первого порта
      
      if(Ua<0){	                         	//ждем когда значение синусоиды станет отрицательной чтобы попасть в цикл    
	 while(Ua<0){                      	// крутимс€ в while пока значение синусоиды не станет положительным (значит прошли ноль из отрицательного в положительное значение
	    Ua = (adc_read(1)-512);
	 }
	 
	 Ub = (adc_read(2)-512);       		//чтение значени€ синусоиды со второго порта
	 Uc = (adc_read(3)-512);       		//чтение значени€ синусоиды с третьего порта
			
	 if (Ub<0 && Uc>0){       		// так как значение Ua уже известно остаетс€ сравнить значени€ Ub и Uc
	    phase_correct ();  			// если фазировка правильна€ будут поочереди загоратьс€ желтый зеленый красный LED потом все вместе
	 } 
	 else{
	    phase_incorrect (); 		// если неправильна€ то загораютс€ красный зеленый желтый и потом все гаснут
	 }
      }
   }
   return 0;
}
   
/* инициализаци€ ј÷ѕ */
void adc_ini(){
   ADMUX&=~((1<<REFS1)/(1<<REFS0)); 				// опорное напр€жение AREF, Internal VREF turned off
   ADMUX&=~(1<<ADLAR);              				// вначале младший регситр
   ADCSRA|=(1<<ADEN);               				//разрешить работу ј÷ѕ
   ADCSRA&=~(1<<ADATE);             				//режим одиночного преобразовани€
   ADCSRA|=(1<<ADPS0) | (1<<ADPS1)| (1<<ADPS2);           	// делитель 128
   //ADCSRA&=~(1<<ADPS0); ADCSRA|=(1<<ADPS1)| (1<<ADPS2);    	// делитель 64
   //ADCSRA|=(1<<ADPS0); ADCSRA&=~((1<<ADPS1)| (1<<ADPS2));  	// делитель 2
} 

/* Ќастройки и чтени€ данных с указанного порта */ 
int16_t adc_read(uint8_t channel){
   ADMUX&=0b11100000;        	// очистить биты MUX (в старших трех настройки)
   ADCSRB&=~(1<<MUX5);     	//по умолчанию все равно нолль
   ADMUX|=channel;           	// выбор канала
   ADCSRA|=(1<<ADSC);        	// запуск преобразовани€
   while(ADCSRA&(1<<ADSC));  	// ожидание окончани€ преобразовани€
   return ADC;               	// вернуть результат
}

/* —игнализации правильной фазировки */
void phase_correct (){
   PORTD = 0b00000010;
   _delay_ms(3000);
   PORTD = 0b00000100;
   _delay_ms(3000);
   PORTD = 0b0001000;
   _delay_ms(3000);
}

/* —игнализации неправильной фазировки */
void phase_incorrect (){
      PORTD = 0b00001110;
}
